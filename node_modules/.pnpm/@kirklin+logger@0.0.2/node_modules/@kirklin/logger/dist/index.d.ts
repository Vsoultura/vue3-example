/**
 * Numeric log level. A higher number is higher severity.
 */
declare enum Level {
    Trace = 0,
    Debug = 1,
    Info = 2,
    Warn = 3,
    Error = 4
}

/**
 * A message field.
 */
declare class Field<T> {
    readonly identifier: string;
    readonly value: T;
    constructor(identifier: string, value: T);
    toJSON(): {
        identifier: string;
        value: T;
    };
}
/**
 * A field to show with the message.
 */
declare const field: <T>(name: string, value: T) => Field<T>;

/**
 * A generic argument to log alongside a message.
 */
type Argument = any;
/**
 * `undefined` is allowed to make it easier to conditionally display a field.
 * For example: `error && field("error", error)`
 */
type FieldArray = Array<Field<Argument> | undefined>;
/**
 * Functions can be used to remove the need to perform operations when the
 * logging level won't output the result anyway.
 */
type LogCallback = () => [string, ...FieldArray];

/**
 * Represents a message formatted for use with something like `console.log`.
 */
interface MessageFormat {
    /**
       * For example, something like `[%s] %s`.
       */
    format: "";
    /**
       * The arguments that get applied to the format string.
       */
    args: string[];
    /**
       * The fields to add under the message.
       */
    fields: Field<Argument>[];
}

/**
 * Abstract formatter for log entry
 */
declare abstract class Formatter {
    private readonly formatType;
    private readonly useColors;
    private message;
    private readonly minimumTagWidth;
    protected constructor(formatType?: string, useColors?: boolean);
    /**
     * Add tag
     */
    tag(name: string, color: string): void;
    /**
     * Add field or argument
     */
    push(fields: Field<Argument>[]): void;
    push(arg: Argument, color?: string, weight?: string): void;
    /**
     * Write log entry
     */
    write(level: Level): void;
    /**
     * Reset state and return message
     */
    protected flush(): MessageFormat;
    /**
     * Return string with style
     */
    protected abstract style(color?: string, weight?: string): string;
    /**
     * Return string to reset style
     */
    protected abstract reset(): string;
    /**
     * Write log entry
     */
    protected abstract doWrite(level: Level, message: MessageFormat): void;
    /**
     * Return format string based on argument type
     */
    private getType;
}

/**
 * Represents a log message, its fields, level, and color.
 */
interface Message {
    message: string | LogCallback;
    fields?: FieldArray;
    level: Level;
    tagColor: string;
}
/**
 * An extra function to call with a message.
 */
type Extender = (msg: Message & {
    section?: string;
}) => void;

declare class Logger {
    private _formatter;
    private readonly name?;
    private readonly defaultFields?;
    private readonly extenders;
    level: Level;
    private readonly nameColor?;
    private muted;
    constructor(_formatter: Formatter, name?: string | undefined, defaultFields?: FieldArray | undefined, extenders?: Extender[]);
    set formatter(formatter: Formatter);
    get formatter(): Formatter;
    /**
     * Suppresses all output
     */
    mute(): void;
    extend(extender: Extender): void;
    info(fn: LogCallback): void;
    info(message: string, ...fields: FieldArray): void;
    warn(fn: LogCallback): void;
    warn(message: string, ...fields: FieldArray): void;
    trace(fn: LogCallback): void;
    trace(message: string, ...fields: FieldArray): void;
    debug(fn: LogCallback): void;
    debug(message: string, ...fields: FieldArray): void;
    error(fn: LogCallback): void;
    error(message: string, ...fields: FieldArray): void;
    /**
     * Returns a sub-logger with a name.
     * Each name is deterministically generated a color.
     */
    named(name: string, ...fields: FieldArray): Logger;
    private handle;
    /**
     * Hashes a string.
     */
    private djb2;
    private rgbToHex;
    /**
     * Generates a deterministic color from a string using hashing.
     */
    private hashStringToColor;
}
declare const logger: Logger;

/**
 * Display logs in the browser using CSS in the output. Fields are displayed on
 * individual lines within a group.
 */
declare class BrowserFormatter extends Formatter {
    constructor();
    protected style(color?: string, weight?: string): string;
    protected reset(): string;
    doWrite(level: Level, message: MessageFormat): void;
}

/**
 * Display logs on the command line using ANSI color codes. Fields are displayed
 * in a single stringified object inline.
 */
declare class ServerFormatter extends Formatter {
    constructor();
    protected style(color?: string, weight?: string): string;
    protected reset(): string;
    private hex;
    private hexToRgb;
    protected doWrite(level: Level, message: MessageFormat): void;
}

/**
 * A time field.
 */
declare class Time {
    readonly expected: number;
    readonly ms: number;
    constructor(expected: number, ms: number);
}
/**
 * Log how long something took. Call this before doing the thing then pass it
 * into the logger after finished to log the time it took.
 */
declare const time: (expected: number) => Time;

export { Argument, BrowserFormatter, Extender, Field, FieldArray, Formatter, Level, LogCallback, Logger, Message, MessageFormat, ServerFormatter, Time, field, logger, time };
